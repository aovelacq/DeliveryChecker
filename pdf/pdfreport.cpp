#include "pdfreport.h"
#include <QDebug>
#include <QApplication>
#include <QFile>
#include <QDateTime>
#include <QHeaderView>
#include "barcode128.h"

unsigned int mmToPixel(double mm)
{
    return static_cast<unsigned int>(mm*3.7795275591);
}

PdfReport::PdfReport(QWidget *parent) : QWidget(parent)
{
    table = new PDFTableView(this);
    table->setObjectName("tabletemp");
    table->hide();
}
void PdfReport::createDocument()
{
    QFile::remove("C:\\Users\\axelo\\VELEC\\PROJETS\\Peruri\\DataBase\\Data\\test.pdf");
    pdfWriter = new QPdfWriter(QString("C:\\Users\\axelo\\VELEC\\PROJETS\\Peruri\\DataBase\\Data\\test.pdf"));
    pdfWriter->setPageSize(QPageSize(QPageSize::A4));
    pdfWriter->setResolution(300);
    QMarginsF docMargins(margin,margin,margin,margin);
    pdfWriter->setPageMargins(docMargins,QPageLayout::Millimeter);
    pdfWriter->setPageOrientation(QPageLayout::Portrait);
    QPainter painter(pdfWriter);
    painter.setBackgroundMode(Qt::TransparentMode);
    createResume(&painter);
}

void PdfReport::createPage(QPainter *painter)
{
    painter->resetMatrix();
    painter->save();
    pageNumber++;
    HeaderRect = createHeader(painter);

    FooterRect = createFooter(painter);
    painter->restore();
    painter->translate(QPoint(0,HeaderRect.height()+50));
}

QRect PdfReport::createHeader(QPainter *painter)
{
    const uint interline = 15;
    int textWidth;
    QPoint startLinePoint,endLinePoint;

    QFont font;
    font.setPointSize(7);
    painter->setFont(font);

    QPen pen;
    pen.setWidth(3);
    painter->setPen(pen);

    QFontMetrics fm(painter->font());
    const int textHeight=fm.height();

    const QPixmap Logo(":/img/img/logopdf.png");
    const QRect logoRect(0,0,Logo.width(),Logo.height());
    painter->drawPixmap(logoRect,Logo);

    const QString date = QString("Generated on : %1 at %2").arg(QDate::currentDate().toString("dddd dd MMMM yyyy"), QTime::currentTime().toString("hh:mm:ss AP"));
    textWidth=fm.horizontalAdvance(date);
    const QRect dateRect(pdfWriter->width()-textWidth,logoRect.bottom()-textHeight,textWidth,textHeight);
    painter->drawText(dateRect,Qt::AlignBottom | Qt::AlignRight, date);

    startLinePoint = QPoint(0,logoRect.bottom()+interline);
    endLinePoint = QPoint(pdfWriter->width(),logoRect.bottom()+interline);
    painter->drawLine(startLinePoint,endLinePoint);

    const QString idx = QString::number(static_cast<uint>(static_cast<double>(QTime::currentTime().msecsSinceStartOfDay())/864.0)).rightJustified(6,'0');
    const QString ref = QString("Report reference : %1-%2-%3").arg(QDate::currentDate().toString("yyyyMMdd"),"99",idx);
    textWidth=fm.horizontalAdvance(ref);
    const QRect refRect(0,startLinePoint.y()+pen.width()+interline,textWidth,textHeight);
    painter->drawText(refRect,Qt::AlignVCenter | Qt::AlignLeft,ref);

    const QString user = QString("Edited by : %1/%2").arg(QSysInfo::machineHostName(),getenv("USERNAME"));
    textWidth=fm.horizontalAdvance(ref);
    const QRect userRect(0,refRect.bottom()+interline,textWidth,textHeight);
    painter->drawText(userRect,Qt::AlignVCenter | Qt::AlignLeft,user);

    const QString soft = QString("Generated by : %1 %2").arg(QCoreApplication::applicationName(), QCoreApplication::applicationVersion());
    textWidth=fm.horizontalAdvance(soft);
    const QRect softRect(0,userRect.bottom()+interline,textWidth,textHeight);
    painter->drawText(softRect,Qt::AlignVCenter | Qt::AlignLeft,soft);

    startLinePoint = QPoint(0,softRect.bottom()+interline);
    endLinePoint = QPoint(pdfWriter->width(),softRect.bottom()+interline);
    painter->drawLine(startLinePoint,endLinePoint);

    BarCode128 barcode;
    QImage image = barcode.getImage(pdfWriter->width()-logoRect.width()-200,125,QString("%1-%2-%3").arg(QDate::currentDate().toString("yyyyMMdd"),"99",idx));
    painter->drawImage(pdfWriter->width()-image.width(),logoRect.top()+50,image);

    return QRect(0,0,pdfWriter->width(),startLinePoint.y()+interline);
}

QRect PdfReport::createFooter(QPainter *painter)
{
    const uint interline = 15;
    QPoint startLinePoint,endLinePoint;

    QPen pen;
    pen.setWidth(3);
    painter->setPen(pen);

    QFont font;
    font.setPointSize(7);
    painter->setFont(font);

    QFontMetrics fm(painter->font());
    const int textHeight=fm.height();

    startLinePoint = QPoint(0,pdfWriter->height()-textHeight/2);
    endLinePoint = QPoint(pdfWriter->width()/2-100,pdfWriter->height()-textHeight/2);
    painter->drawLine(startLinePoint,endLinePoint);

    const QRect pageRect(pdfWriter->width()/2-100,pdfWriter->height()-textHeight,200,textHeight);
    painter->drawText(pageRect,Qt::AlignCenter,QString("%1").arg(pageNumber));

    startLinePoint = QPoint(pdfWriter->width()/2+100,pdfWriter->height()-textHeight/2);
    endLinePoint = QPoint(pdfWriter->width(),pdfWriter->height()-textHeight/2);
    painter->drawLine(startLinePoint,endLinePoint);

    return QRect(0,pdfWriter->height()-textHeight-interline,pdfWriter->width(),textHeight+interline);

}

void PdfReport::createResume(QPainter *painter)
{
    createPage(painter);
    insertTitle(painter);
    insertTable(painter, table, QPoint(0,0),true);
}

void PdfReport::insertTitle(QPainter *painter)
{
    QFont font;
    font.setPointSize(20);
    font.setCapitalization(QFont::SmallCaps);
    painter->setFont(font);

    QFontMetrics fm(painter->font());
    const int textHeight=fm.height();

    const QString title = "DELIVERY REPORT";
    const QRect titleRect(0,0,pdfWriter->width(),textHeight);
    painter->drawText(titleRect,Qt::AlignCenter, title);
    painter->translate(0,titleRect.height()+50);
}



QPoint PdfReport::insertTable(QPainter *painter, PDFTableView* table, QPoint pos, bool coloredStatus)
{
    painter->translate(pos);
    QPoint ActPos(0,0);
    int nbLine = table->model()->rowCount();
    int nbColumn = table->model()->columnCount();
    int cellwidth = pdfWriter->width()/nbColumn;
    int headerHeight = table->horizontalHeader()->height();
    int rowHeight = table->rowHeight(1);
    QRect cell;
    QFont font;
    QRect footerRect;
    QBrush brush(painter->brush());
    int idxLine =0,idxCol=0;

    // Draw Header
    {
    // Set header font
    font.setPointSize(10);
    font.setCapitalization(QFont::MixedCase);
    painter->setFont(font);
    brush.setColor(Qt::white);
    painter->setBrush(brush);
    // Check if it intersects the footer and create a new page if necessary (must display 1 row min)
    footerRect = QRect(FooterRect.x()-painter->worldMatrix().dx(),FooterRect.y()-painter->worldMatrix().dy(),FooterRect.width(), FooterRect.height());
    if (QRect(0,0,cellwidth,headerHeight+rowHeight).intersects(footerRect))
    {
        pdfWriter->newPage();
        ActPos=QPoint(0,0);
        createPage(painter);
    }
    //Draw each cell and fill it with header data
    for(int col=0;col<nbColumn;col++)
    {
        cell = QRect(col*cellwidth+ActPos.x(),ActPos.y(),cellwidth,headerHeight);
        painter->drawRect(cell);
        painter->drawText(cell, Qt::AlignCenter, table->model()->headerData(col,Qt::Horizontal).toString());
    }
    //Set the new vertical position
    ActPos.setY(ActPos.y()+headerHeight);
    }

    //Draw table
    {
    // Set table font
    font.setPointSize(6);
    font.setCapitalization(QFont::MixedCase);
    painter->setFont(font);
    painter->setBrush(QBrush(Qt::transparent));
    // Loop for each model data
    for(int line=0;line<nbLine;line++)
    {
        idxCol=0;
        for(int col=0;col<nbColumn;col++)
        {

            //Check if the row interseacts the footer and create a new page if necessary
            footerRect = QRect(FooterRect.x()-painter->worldMatrix().dx(),FooterRect.y()-painter->worldMatrix().dy(),FooterRect.width(), FooterRect.height());
            cell = QRect(idxCol*cellwidth+ActPos.x(),idxLine*rowHeight+ActPos.y(),cellwidth,rowHeight);
            if (cell.intersects(footerRect))
            {
                pdfWriter->newPage();
                ActPos=QPoint(0,0);
                createPage(painter);
                // Set header again
                font.setPointSize(10);
                font.setCapitalization(QFont::MixedCase);
                painter->setFont(font);
                for(int col=0;col<nbColumn;col++)
                {
                    cell = QRect(col*cellwidth+ActPos.x(),ActPos.y(),cellwidth,headerHeight);
                    painter->drawRect(cell);
                    painter->drawText(cell, Qt::AlignCenter, table->model()->headerData(col,Qt::Horizontal).toString());
                }
                idxLine = 0;
                ActPos.setY(ActPos.y()+headerHeight);
                // Actual cell calculation
                cell = QRect(idxCol*cellwidth+ActPos.x(),idxLine*rowHeight+ActPos.y(),cellwidth,rowHeight);
                // Set table font
                font.setPointSize(6);
                font.setCapitalization(QFont::MixedCase);
                painter->setFont(font);
            }
            //Draw cell and fill it with header data
            if (idxCol==0 && coloredStatus)
            {
                painter->drawRect(cell);
                if (table->model()->index(line,col).data().toString() == "OK")
                    painter->setBrush(QBrush(Qt::green));
                else if (table->model()->index(line,col).data().toString() == "")
                    painter->setBrush(QBrush(Qt::red));
                painter->fillRect(QRect(cell.x()+4,cell.y()+4,cell.height()-8,cell.height()-8),painter->brush());
                painter->drawRect(QRect(cell.x()+4,cell.y()+4,cell.height()-8,cell.height()-8));
                painter->drawText(QRect(cell.x()+cell.height()+10,cell.y()+4,cell.width()-(cell.x()+cell.height()+4),cell.height()-8), Qt::AlignLeft | Qt::AlignVCenter, table->model()->index(line,col).data().toString()=="OK"?"Scanned":"Not Scanned");
            }
            else
            {

                painter->setBrush(QBrush(Qt::transparent));
                painter->drawRect(cell);
                painter->drawText(cell, Qt::AlignCenter, table->model()->index(line,col).data().toString());
            }
            idxCol++;
        }
        idxLine++;
    }
    }

    return ActPos;

}
